import{_ as i,D as n,c as r,I as e,w as a,ab as s,o as _,j as t}from"./chunks/framework.BGN0zjd9.js";const z=JSON.parse('{"title":"算法无处不在","description":"","frontmatter":{},"headers":[],"relativePath":"01_Programmer/04_Algorithm/01_第1章_初识算法/01_算法无处不在.md","filePath":"01_Programmer/04_Algorithm/01_第1章_初识算法/01_算法无处不在.md","lastUpdated":1723861775000}'),p={name:"01_Programmer/04_Algorithm/01_第1章_初识算法/01_算法无处不在.md"},c=s('<h1 id="算法无处不在" tabindex="-1">算法无处不在 <a class="header-anchor" href="#算法无处不在" aria-label="Permalink to &quot;算法无处不在&quot;">​</a></h1><p>当我们听到“算法”这个词时，很自然地会想到数学。然而实际上，许多算法并不涉及复杂数学，而是更多地依赖基本逻辑，这些逻辑在我们的日常生活中处处可见。</p><p>在正式探讨算法之前，有一个有趣的事实值得分享： <strong>你已经在不知不觉中学会了许多算法，并习惯将它们应用到日常生活中了</strong> 。下面我将举几个具体的例子来证实这一点。</p><p><strong>例一：查字典。</strong> 在字典里，每个汉字都对应一个拼音，而字典是按照拼音字母顺序排列的。假设我们需要查找一个拼音首字母为 的字，通常会按照图 1-1 所示的方式实现。</p><ol><li>翻开字典约一半的页数，查看该页的首字母是什么，假设首字母为m.</li><li>由于在拼音字母表中r位于m之后，所以排除字典前半部分，查找范围缩小到后半部分。</li><li>不断重复步骤 1. 和 步骤 2. ，直至找到拼音首字母为r的页码为止。</li></ol>',5),g=t("p",null,[t("img",{src:"https://raw.githubusercontent.com/cheng000/picture/main/vitepress-blog/20240815124605.png",alt:"",loading:"lazy"})],-1),m=t("p",null,[t("img",{src:"https://raw.githubusercontent.com/cheng000/picture/main/vitepress-blog/20240815124652.png",alt:"",loading:"lazy"})],-1),u=t("p",null,[t("img",{src:"https://raw.githubusercontent.com/cheng000/picture/main/vitepress-blog/20240815124754.png",alt:"",loading:"lazy"})],-1),h=t("p",null,[t("img",{src:"https://raw.githubusercontent.com/cheng000/picture/main/vitepress-blog/20240815124809.png",alt:"",loading:"lazy"})],-1),d=t("p",null,[t("img",{src:"https://raw.githubusercontent.com/cheng000/picture/main/vitepress-blog/20240815124823.png",alt:"",loading:"lazy"})],-1),b=s('<p>图 1-1 查字典步骤</p><p>查字典这个小学生必备技能，实际上就是著名的“二分查找”算法。从数据结构的角度，我们可以把字典视为一个已排序的“数组”；从算法的角度，我们可以将上述查字典的一系列操作看作“二分查找”。</p><p><strong>例二：整理扑克。</strong> 我们在打牌时，每局都需要整理手中的扑克牌，使其从小到大排列，实现流程如图 1-2 所示。</p><ol><li>将扑克牌划分为“有序”和“无序”两部分，并假设初始状态下最左 1 张扑克牌已经有序。</li><li>在无序部分抽出一张扑克牌，插入至有序部分的正确位置；完成后最左 2 张扑克已经有序。</li><li>不断循环步骤 2. ，每一轮将一张扑克牌从无序部分插入至有序部分，直至所有扑克牌都有序。</li></ol><p><img src="https://raw.githubusercontent.com/cheng000/picture/main/vitepress-blog/20240815125005.png" alt="" loading="lazy"> 图 1-2 扑克排序步骤</p><p>上述整理扑克牌的方法本质上是“插入排序”算法，它在处理小型数据集时非常高效。许多编程语言的排序库函数中都有插入排序的身影。</p><p><strong>例三：货币找零.</strong> 假设我们在超市购买了69元的商品，给了收银员100元，则收银员需要找我们31元。他会很自然地完成如图 1-3 所示的思考。 <img src="https://raw.githubusercontent.com/cheng000/picture/main/vitepress-blog/20240815125138.png" alt="" loading="lazy"> 图 1-3 货币找零过程</p><p>在以上步骤中，我们每一步都采取当前看来最好的选择（尽可能用大面额的货币），最终得到了可行的找零方案。从数据结构与算法的角度看，这种方法本质上是“贪心”算法。</p><p>小到烹饪一道菜，大到星际航行，几乎所有问题的解决都离不开算法。计算机的出现使得我们能够通过编程将数据结构存储在内存中，同时编写代码调用 CPU 和 GPU 执行算法。这样一来，我们就能把生活中的问题转移到计算机上，以更高效的方式解决各种复杂问题。</p>',9);function T(P,f,v,w,A,S){const l=n("PluginTabsTab"),o=n("PluginTabs");return _(),r("div",null,[c,e(o,null,{default:a(()=>[e(l,{label:"step 1"},{default:a(()=>[g]),_:1}),e(l,{label:"step 2"},{default:a(()=>[m]),_:1}),e(l,{label:"step 3"},{default:a(()=>[u]),_:1}),e(l,{label:"step 4"},{default:a(()=>[h]),_:1}),e(l,{label:"step 5"},{default:a(()=>[d]),_:1})]),_:1}),b])}const C=i(p,[["render",T]]);export{z as __pageData,C as default};
